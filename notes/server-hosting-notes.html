<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.classless.slate.min.css"
    />
    <link href="/styles/prism.css" rel="stylesheet" />
    <title>Server Hosting Notes</title>
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li>
            <strong><a href="/">Doug's Site</a></strong>
          </li>
        </ul>
        <ul>
          <li><a href="/notes">Notes</a></li>
        </ul>
      </nav>
    </header>
    <main>
      <h1>Server Hosting Notes</h1>
      <h2>Server OS Setup</h2>
      <p>The server that hosts this website is at Digital Ocean.</p>
      <p>
        To setup access I am using ssh keys, which can be created with the
        <code class="language-bash">ssh-keygen</code> command, and then copied
        to the server with <code class="language-bash">ssh-copy-id</code>.
      </p>
      <p>
        You also want to make sure that the server has been updated recently,
        which can be done with the
        <code class="language-bash">apt update &amp;&amp; apt upgrade</code>
        commands on Ubuntu.
      </p>
      <h2>Web Server Setup</h2>
      <p>
        Most of my career nowadays has been using AWS infrastructure with
        services like Lambda and ECS/EKS. While this is great for scalability,
        it is very overkill for a personal website. So for this site I am using
        a standard web server to serve static files. This was also slightly
        influenced by reading
        <a href="http://www.aaronsw.com/weblog/000404">Aaron Swartz's blog</a>.
      </p>
      <p>
        Before we set up the web server, we need to setup a firewall. Since
        we're using Ubuntu, we can use UFW (Uncomplicated Firewall) for this
        purpose. The following commands will allow SSH and HTTP/HTTPS traffic:
      </p>
      <pre><code class="language-bash">sudo apt install ufw
sudo ufw allow 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
sudo ufw status</code></pre>
      <p>
        For the web server, I decided to use Nginx. Luckily, NGINX is super easy
        to get installed and running. Just run
        <code class="language-bash">sudo apt-get install nginx</code>. Once it's
        installed, it automatically starts running. You can check its status
        with <code class="language-bash">sudo systemctl status nginx</code>. You
        should be able to visit your server's IP address in a web browser and
        see the default NGINX welcome page.
      </p>
      <p>
        So now we have a server. We need to get our website files onto it! The
        first step is making the directory where the website files will live. By
        default, NGINX serves files from
        <code class="language-bash">/var/www/html</code>. Since you always want
        to assume you're going to run multiple websites on a server, it's a good
        idea to create a separate directory for each site. So let's create a
        directory for this site:
        <code class="language-bash">mkdir /var/www/dougs-site</code>.
      </p>
      <p>
        And now we have to setup the NGINX configuration for this site. For this
        site, here is the file:
      </p>
      <pre><code class="language-nginx">server {
    listen 80;
    root /var/www/dougs-site;

    server_name dsknr.com www.dsknr.com 157.245.119.227;

    location / {
        try_files $uri $uri/ =404;
    }
}</code></pre>
      <p>
        First we need to put that file in the NGINX sites-available directory:
        <code class="language-bash"
          >sudo vi /etc/nginx/sites-available/dougs-site</code
        >. Then we need to create a symbolic link to it in the sites-enabled
        directory, which NGINX actually uses:
        <code class="language-bash"
          >sudo ln -s /etc/nginx/sites-available/dougs-site
          /etc/nginx/sites-enabled/</code
        >. Finally, we need to test the NGINX configuration for syntax errors
        and reload NGINX to apply the changes:
        <code class="language-bash"
          >sudo nginx -t &amp;&amp; sudo systemctl reload nginx</code
        >.
      </p>
      <p>
        Now we need to get the actual files there! For now we're going to use
        rsync:
      </p>
      <pre><code class="language-bash">rsync -avz --delete ./* tinysite:/var/www/dougs-site/</code></pre>
      <p>And this let's you go to the IP address and see the files!</p>

      <h2>Automated Deployment with GitHub Actions</h2>
      <p>
        While manual deployment with rsync works fine, it's much more convenient
        to have deployments happen automatically when code is pushed to the
        repository. GitHub Actions can handle this automatically.
      </p>
      <p>
        The workflow is configured in
        <code class="language-bash">.github/workflows/deploy.yml</code> and
        runs on every push to the master branch. Here's how it works:
      </p>
      <pre><code class="language-yaml">name: Deploy to Server

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy with rsync
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude '.git' \
            --exclude '.github' \
            --exclude 'README.md' \
            ./ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.SERVER_PATH }}

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key</code></pre>
      <p>
        The workflow uses GitHub Secrets to securely store sensitive information.
        You need to configure these secrets in your repository settings under
        Settings → Secrets and variables → Actions:
      </p>
      <ul>
        <li>
          <strong>SSH_PRIVATE_KEY</strong> - Your SSH private key for server
          authentication. Generate a dedicated key pair with
          <code class="language-bash">ssh-keygen -t ed25519 -C "github-actions-deploy"</code>,
          add the public key to the server's
          <code class="language-bash">~/.ssh/authorized_keys</code>, and paste
          the entire private key (including BEGIN and END lines) into this secret.
        </li>
        <li>
          <strong>SERVER_HOST</strong> - The server hostname or IP address
          (e.g., <code class="language-bash">157.245.119.227</code>)
        </li>
        <li>
          <strong>SERVER_USER</strong> - SSH username on the server (e.g.,
          <code class="language-bash">root</code>)
        </li>
        <li>
          <strong>SERVER_PATH</strong> - Destination path on the server:
          <code class="language-bash">/var/www/dougs-site</code>
        </li>
      </ul>
      <p>
        The workflow uses the same rsync command as manual deployment but with
        the <code class="language-bash">--delete</code> flag to remove files on
        the server that don't exist in the repository. It excludes Git-related
        files and the README to keep the deployment clean.
      </p>

      <p>
        Now, we need to get our domain name set up. I have my domain hosted with
        Namecheap, so I will log into my Namecheap account and update the DNS
        settings to point to my server's IP address.
      </p>
      <p>
        Finally, in this day and age, every website should be behind HTTPS with
        a valid SSL certificate. You can use Let's Encrypt to obtain a free SSL
        certificate and configure NGINX to use it. To install Certbot run:
      </p>
      <pre><code class="language-bash">sudo snap install --classic certbot</code></pre>
      <p>
        And now we need to make the command executable:
        <code class="language-bash"
          >sudo ln -s /snap/bin/certbot /usr/local/bin/certbot</code
        >
      </p>
      <p>
        And then finally run certbot:
        <code class="language-bash">sudo certbot --nginx</code>
      </p>
    </main>
    <script src="/scripts/prism.js"></script>
  </body>
</html>
